#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_GOOGLE_include_directive : enable
#include "brdf.h"
#include "math.glsl"
#include "../shared/shared.h"

vec3 viridis_quintic( float x )
{
	x = saturate( x );
	vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3
	vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
	return vec3(
		dot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),
		dot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),
		dot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D path_tracer_input_image;
layout(binding = 1, set = 0, rgba32f) uniform image2D raster_input_image;
layout(binding = 2, set = 0, rgba32f) uniform image2D normal_roughness;
layout(binding = 3, set = 0, rgba32f) uniform image2D basecolor_metalness;
layout(binding = 4, set = 0) uniform sampler2D depth;
layout(binding = 5, set = 0, rgba32f) uniform image2D indirect_diffuse;
layout(binding = 6, set = 0, rgba32f) uniform image2D denoiser_output;
layout(binding = 7, set = 0, rgba32f) uniform image2D output_image;
layout(binding = 8, set = 0) uniform sampler2D history_fix;
layout(binding = 9, set = 0) uniform sampler2D history_fix_depth;
layout(binding = 10, set = 0) readonly buffer global_constants_t
{
    Global_Constants_Data data;
} global_constants;

layout( push_constant ) uniform constants
{
    mat4 inv_proj;
    ivec2 size;
    float image_split_pos;
    uint history_lod;
} control;

void main()
{
    ivec3 p = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(p.xy, control.size)))
        return;
    
    int split_pixel = int(float(control.size.x) * control.image_split_pos);
    const float exposure = 1.0;
    vec4 color = vec4(0.0);
    if (p.x <= split_pixel)
        color = imageLoad(path_tracer_input_image, p.xy);
    else
        color = imageLoad(raster_input_image, p.xy);
    vec2 uv = vec2(p.xy + 0.5) / vec2(control.size);

    vec4 normal_roughness = imageLoad(normal_roughness, p.xy);
    vec4 basecolor = imageLoad(basecolor_metalness, p.xy);
    //color.rgb = v.rgb;
    vec3 normal = decode_unit_vector(normal_roughness.rg, false, true);
    float depth = texelFetch(depth, p.xy, 0).r;
    vec4 indirect_diffuse = imageLoad(indirect_diffuse, p.xy);

    vec4 denoised = imageLoad(denoiser_output, p.xy);

    vec3 albedo = basecolor.rgb * (1.0 - basecolor.a);


    vec4 history_fix = textureLod(history_fix, uv, control.history_lod);
    if (control.history_lod == 0)
        history_fix = denoised;

    // Reinhardt tonemapping
    color.rgb = color.rgb / (color.rgb + 1.0);
    color.rgb *= exposure;
    vec3 gamma_corrected = pow(color.rgb, vec3(0.4545));
    //vec3 gamma_corrected = color.rgb;

    //imageStore(output_image, p.xy, vec4(normal * 0.5 + 0.5, 1.0));

    vec2 ndc = (vec2(p.xy) + 0.5) / imageSize(raster_input_image);
    ndc = ndc * 2.0 - 1.0;
    vec4 screen_space = vec4(ndc, depth, 1.0);

    // These work
    vec4 view_space = control.inv_proj * screen_space;
    view_space.xyz /= view_space.w;
    float view_z = 1.0 / (control.inv_proj[2][3] * depth);

    float history_fix_z = textureLod(history_fix_depth, uv, control.history_lod).r;

    vec3 final_output = vec3(0.0);

    switch (global_constants.data.screen_output)
    {
        case 0: // final composition
            final_output = gamma_corrected.rgb;
            break;
        case 1: // noisy indirect diffuse
            final_output = indirect_diffuse.rgb;
            break;
        case 2: // denoised indirect diffuse
            final_output = denoised.rgb;
            break;
        case 3: // hit distance (not implemented)
            final_output = vec3(1.0, 0.0, 1.0);
            break;
        case 4: // blur radius (not implemented)
            final_output = vec3(1.0, 0.0, 1.0);
            break;
        case 5: // history length
            final_output = viridis_quintic(1.0 - denoised.a / 32.0);
            break;
        default:
            break;
    }

    if (p.x < split_pixel)
        imageStore(output_image, p.xy, vec4(gamma_corrected.rgb, 1.0));
    else
    {
        //imageStore(output_image, p.xy, vec4(history_fix.rgb, 1.0));
        float norm_history = (denoised.a - 1.0) / 4.0;
        norm_history = clamp(norm_history, 0.0, 1.0);
#if 0
        if (norm_history < 1.0)
            imageStore(output_image, p.xy, vec4(vec3(viridis_quintic(1.0 - norm_history)), 1.0));
        else
#endif
        //imageStore(output_image, p.xy, vec4(viridis_quintic(1.0 - denoised.a / 32.0), 1.0));
        imageStore(output_image, p.xy, vec4(final_output.rgb, 1.0));
        //imageStore(output_image, p.xy, vec4(vec3(history_fix_z / 1000.0), 1.0));
        //imageStore(output_image, p.xy, vec4(gamma_corrected.rgb, 1.0));
        //imageStore(output_image, p.xy, vec4((vec3(basecolor.rgb), 1.0)));
    }

    //vec4 v = imageLoad(test_img, p.xy + ivec2(0, 500));
    //imageStore(output_image, p.xy, v);
    //imageStore(output_image, p.xy, vec4(1.0, 0.0, 1.0, 1.0));
}