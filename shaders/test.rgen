#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_ray_tracing : require
#extension  GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : require

#include "test.glsl"
#include "scene.glsl"
#include "random.glsl"
#include "math.glsl"
#include "material.glsl"

layout( push_constant ) uniform constants
{
    uint frames_accumulated;
} control;

layout(location = 0) rayPayloadEXT Ray_Payload pay;
layout(binding = 0, set = 0, rgba32f) uniform image2D output_image;
layout(binding = 1, set = 0) uniform accelerationStructureEXT scene;
layout(binding = 3, set = 0) uniform sampler2D environment_map;

layout (set = 1, binding = 0) uniform sampler2D textures[];
layout (set = 1, binding = 1, scalar) readonly buffer vertex_buffer_array_t
{
    Vertex_Data verts[];
} vertex_buffer_array[];
layout (set = 1, binding = 2, scalar) readonly buffer index_buffer_array_t
{
    Index_Data indices[];
} index_buffer_array[];
layout (set = 1, binding = 3, scalar) readonly buffer material_array_t
{
    Material materials[];
} material_array;

vec3 sample_environment_map(vec3 dir, sampler2D s)
{
    // y = -cos(theta) -> theta = -arccos(y)
    float theta = acos(-dir.y);
    float phi = atan(dir.z, -dir.x) + M_PI;
    vec2 uv = vec2(phi / (2.0 * M_PI), theta / M_PI);

    return texture(s, uv).rgb;
}

Vertex get_interpolated_vertex(int instance_id, int primitive_id, vec2 barycentrics)
{
    uvec3 inds = index_buffer_array[instance_id].indices[primitive_id].index;
    vec3 v0 = vertex_buffer_array[instance_id].verts[inds.x].pos;
    vec3 v1 = vertex_buffer_array[instance_id].verts[inds.y].pos;
    vec3 v2 = vertex_buffer_array[instance_id].verts[inds.z].pos;

    vec3 n0 = vertex_buffer_array[instance_id].verts[inds.x].normal;
    vec3 n1 = vertex_buffer_array[instance_id].verts[inds.y].normal;
    vec3 n2 = vertex_buffer_array[instance_id].verts[inds.z].normal;

    vec2 t0 = vertex_buffer_array[instance_id].verts[inds.x].texcoord;
    vec2 t1 = vertex_buffer_array[instance_id].verts[inds.y].texcoord;
    vec2 t2 = vertex_buffer_array[instance_id].verts[inds.z].texcoord;

    vec3 N = normalize((1.0 - barycentrics.x - barycentrics.y) * n0 + barycentrics.x * n1 + barycentrics.y * n2);
    vec3 P = (1.0 - barycentrics.x - barycentrics.y) * v0 + barycentrics.x * v1 + barycentrics.y * v2;
    vec2 TX = (1.0 - barycentrics.x - barycentrics.y) * t0 + barycentrics.x * t1 + barycentrics.y * t2;

    Vertex v;
    v.pos = P;
    v.normal = N;
    v.texcoord = TX;

    return v;
}

vec3 L = normalize(vec3(0.0, 1.0, 0.2));

void main()
{
    pay.instance_id = -1;
    uvec4 seed = uvec4( gl_LaunchIDEXT.xy, control.frames_accumulated, 1);
    vec2 pixel = vec2(gl_LaunchIDEXT.xy);
    vec2 offset = vec2(pcg4d(seed)) * ldexp(2.0, -32);
    const vec2 resolution = vec2(gl_LaunchSizeEXT.xy);
    if (control.frames_accumulated != 0)
        pixel += mix(vec2(-0.5), vec2(0.5), offset);

    vec2 uv = (((pixel + 0.5f) / resolution) * 2.f - 1.f);

    mat4 inv_view = inverse(camera_data.view);
    vec3 ro = inv_view[3].xyz;

    float aspect = camera_data.proj[1][1] / camera_data.proj[0][0];
    float tan_half_fov_y = 1.f / camera_data.proj[1][1];
    vec3 rd = normalize(
        (uv.x * inv_view[0].xyz * tan_half_fov_y * aspect) - 
        (uv.y * inv_view[1].xyz * tan_half_fov_y) -
        inv_view[2].xyz);

    // vec3 c = sample_environment_map(rd, environment_map);
    //         traceRayEXT(
    //         scene,
    //         gl_RayFlagsOpaqueEXT,
    //         0xFF,
    //         0,
    //         0,
    //         0,
    //         ro,
    //         0.0,
    //         rd,
    //         100000.0,
    //         0
    //     );
    
    // int geom_id = int((pay.instance_id) & 0x3FFF);
    // int material_id = int((pay.instance_id >> 14) & 0x3FF);
    // Vertex v = get_interpolated_vertex(geom_id, pay.prim_id, pay.barycentrics);
    // Material mat = material_array.materials[material_id];
    // if (gl_LaunchIDEXT.xy == ivec2(640, 360))
    // {
    //     debugPrintfEXT("id: %d, tex_id: %d", material_id, mat.base_color_tex);
    // }
    // vec2 texcoord = v.texcoord;
    // vec3 albedo = mat.base_color_tex != -1 ? textureLod(textures[mat.base_color_tex], texcoord, 0).rgb : mat.base_color_factor.rgb;
    // albedo = pow(albedo, vec3(2.2));
    // if (pay.instance_id != -1)
    //     c = vec3(1.0, 0.0, 1.0);
    // imageStore(output_image, ivec2(gl_LaunchIDEXT), vec4(albedo, 1.0));
    // return;

    // Path tracer loop
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    const int MAX_BOUNCES = 4;
    for (int i = 0; i < MAX_BOUNCES; ++i)
    {
        traceRayEXT(
            scene,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0,
            0,
            0,
            ro,
            0.0,
            rd,
            100000.0,
            0
        );
        if (pay.prim_id != -1)
        {
            int geom_id = int((pay.instance_id) & 0x3FFF);
            int material_id = int((pay.instance_id >> 14) & 0x3FF); 
            Vertex v = get_interpolated_vertex(geom_id, pay.prim_id, pay.barycentrics);
            vec3 normal = v.normal;
            Material mat = material_array.materials[material_id];
            vec3 albedo = mat.base_color_tex != -1 ? textureLod(textures[mat.base_color_tex], v.texcoord, 0).rgb : mat.base_color_factor.rgb;
            albedo = pow(albedo, vec3(2.2));
            if (dot(normal, rd) > 0.0)
                normal = -normal;
            vec3 p = ro + pay.t * rd;
            ro = p + normal * 0.001;
            // Next event estimation
            {
                traceRayEXT(
                    scene,
                    gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
                    0xFF,
                    0,
                    0,
                    0,
                    ro,
                    0.0,
                    L,
                    100000.0,
                    0
                );
                if (pay.prim_id == -1)
                {
                    radiance += throughput * albedo / M_PI * max(0.0, dot(normal, L));
                }
            }

            vec3 new_dir = random_cosine_hemisphere(normal, seed);

            rd = new_dir;
            throughput *= albedo;
        }
        else
        {
            // Miss
            radiance += throughput * sample_environment_map(rd, environment_map);
            break;
        }
    }
    vec3 out_color = radiance.rgb;
    if (control.frames_accumulated != 0)
    {
        vec4 prev_color = imageLoad(output_image, ivec2(gl_LaunchIDEXT));
        float total = control.frames_accumulated + 1.0;
        out_color = mix(out_color.rgb, prev_color.rgb, float(control.frames_accumulated) / total);
    }
    imageStore(output_image, ivec2(gl_LaunchIDEXT), vec4(out_color, 1.0));
}