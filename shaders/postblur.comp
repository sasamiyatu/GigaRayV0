#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension  GL_EXT_scalar_block_layout : enable

#include "blur_common.glsl"
#include "math.glsl"
#include "../shared/shared.h"
#include "misc.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D noisy_input;
layout(binding = 1, set = 0, rgba32f) uniform image2D normal_roughness;
layout(binding = 2, set = 0, rgba32f) uniform image2D world_position;
layout(binding = 3, set = 0) uniform sampler2D depth;
layout(binding = 4, set = 0, rgba32f) uniform image2D blurred_output;
layout(binding = 5, set = 0, scalar) readonly buffer global_constants_t
{
    Global_Constants_Data data;
} global_constants;
layout(binding = 6, set = 0, rgba32f) uniform image2D history_length;
layout(binding = 7, set = 0, scalar) uniform camera_buffer{
    Camera_Data current;
    Camera_Data previous;
} camera_data;
layout(binding = 8, set = 0, rgba32f) uniform image2D debug_output;

layout( push_constant ) uniform constants
{
    mat2 rot;
    ivec2 size;
    float depth_scale;
} control;

float gaussian[3] = {0.27, 0.44, 0.27};

vec2 get_sample_pos(vec3 center, float blur_radius, vec3 offset, vec3 T, vec3 B, mat4 viewproj, mat2 rotation)
{
    T *= blur_radius;
    B *= blur_radius;

    if (global_constants.data.use_quadratic_distribution == 1)
        offset.xy *= offset.z;

    offset.xy = rotation * offset.xy;
    vec3 sample_pos_world = center + T * offset.x + B * offset.y;

    vec4 clip_pos = viewproj * vec4(sample_pos_world, 1.0);
    clip_pos /= clip_pos.w;
    clip_pos.y = -clip_pos.y;

    vec2 uv = clip_pos.xy * 0.5 + 0.5;

    return uv * control.size;
}

void main()
{
    ivec3 p = ivec3(gl_GlobalInvocationID);
    if (any(greaterThan(p.xy, control.size)))
        return;

    vec4 center = imageLoad(noisy_input, p.xy);
    float accumulated_frames = imageLoad(history_length, p.xy).r * 255.0;

    if (global_constants.data.blur_radius == 0.0f || global_constants.data.post_blur_radius_scale == 0.0f)
    {
        imageStore(blurred_output, p.xy, center);
        return;
    }

    //if (p.xy == ivec2(0, 0)) debugPrintfEXT("im here");
    
    vec3 p0 = imageLoad(world_position, p.xy).xyz;
    vec4 n0r0 = imageLoad(normal_roughness, p.xy);
    vec3 N = decode_unit_vector(n0r0.xy, false, true);
    float d0 = texelFetch(depth, p.xy, 0).r;

    if (d0 == 0.0)
    {
        imageStore(blurred_output, p.xy, center);
        return;
    }

    float blur_radius_scale = 1.0 / accumulated_frames;

    vec3 X = (p0 - global_constants.data.camera_origin);

    float Z = control.depth_scale / d0;
    float blur_radius = global_constants.data.blur_radius;
    float hit_dist_normalization = global_constants.data.hit_dist_params.x + global_constants.data.hit_dist_params.y * abs(Z);
    float frustum_size = global_constants.data.min_rect_dim_mul_unproject * abs(Z);
    float hit_t = center.a * hit_dist_normalization;
    float hit_dist_factor = clamp(hit_t / frustum_size, 0.0, 1.0);
    hit_dist_factor = mix(hit_dist_factor, 1.0, 1.0 / accumulated_frames);
    float hit_t0 = center.a;

    if (global_constants.data.hit_distance_scaling == 1)
        blur_radius *= hit_dist_factor;

    if (global_constants.data.frame_num_scaling == 1)
    {
        float frame_count_scale = 1.0 - smoothstep(2.0, 4.0, accumulated_frames);
        blur_radius *= (1.0 + 2.0 * frame_count_scale) / 3.0;
    }

    blur_radius += 1.0; // Avoid underblurring
    blur_radius *= global_constants.data.post_blur_radius_scale;

    mat3 tbn = create_tangent_space(N);
    float world_radius = blur_radius * global_constants.data.unproject * Z;

    // if (p.xy == ivec2(640, 360))
    //     debugPrintfEXT("blur radius scale: %f, radius: %f, world_radius: %f", blur_radius_scale, blur_radius, world_radius);

    float a = 0.25 / ( global_constants.data.plane_distance_sensitivity * frustum_size );
    float b = -dot( N, X ) * a;

    float spec_half_angle = M_PI * 0.5;
    float a0 = global_constants.data.lobe_percentage * spec_half_angle;

    float plane_dist_norm = global_constants.data.plane_dist_norm_scale / (1.0 + Z * global_constants.data.unproject);

    float sum = 1.0;
    vec4 diff = center;

    mat2 rotation = mat2(1.0);
    if (global_constants.data.blur_kernel_rotation_mode == 2)
    {
        uvec4 seed = uvec4(p.x, p.y, global_constants.data.frame_number, 1337);
        vec4 rand = vec4(pcg4d(seed)) *  ldexp(1.0, -32);
        float theta = rand.x * 2.0 * M_PI;
        float cos_theta = cos(theta);
        float sin_theta = sin(theta);
        rotation = mat2(cos_theta, sin_theta, -sin_theta, cos_theta);
    }
    else if (global_constants.data.blur_kernel_rotation_mode == 1)
    {
        rotation = control.rot;
    }

    for (int i = 0; i < NUM_SAMPLES; ++i)
    {
        vec3 offset = poisson_samples[i];

        vec2 sample_pos;
        if (global_constants.data.screen_space_sampling == 1)
            sample_pos = vec2(p.xy + 0.5) + rotation * offset.xy * blur_radius;
        else
            sample_pos = get_sample_pos(p0, world_radius, offset, tbn[0], tbn[1], camera_data.current.viewproj, rotation);

        ivec2 q = ivec2(sample_pos);

        bool is_in_screen = (all(greaterThanEqual(q.xy, ivec2(0, 0))) && all(lessThan(q.xy, control.size)));

        if (p.xy == ivec2(640, 360) && is_in_screen)
        {
            //debugPrintfEXT("q: %d %d", q.x, q.y);
            imageStore(debug_output, q.xy, vec4(viridis_quintic(offset.z), 1.0));
        }

        vec4 s = imageLoad(noisy_input, q.xy);
        vec3 pos = imageLoad(world_position, q.xy).xyz;
        vec3 Xs = pos - global_constants.data.camera_origin;
        vec3 nr = imageLoad(normal_roughness, q.xy).xyz;
        vec3 Ns = decode_unit_vector(nr.xy, false, true);
        float w = 1.0;
        if (global_constants.data.use_gaussian_weight == 1)
            w = get_gaussian_weight(offset.z);

        float ndotx = dot(Xs, Ns);
        float plane_dist_w = abs(ndotx * a + b);

        //float w_plane = smoothstep(saturate(1))

        // if (p.xy == ivec2(640, 360))
        //     debugPrintfEXT("plane w: %f", w_plane);

        float cosa = clamp(dot(Ns, N), 0.0, 1.0);
        float a = acos(cosa);
        float w_n = smoothstep(a0, 0.0, a);

        vec3 ray = pos - p0;
        float dist_to_plane = abs(dot(ray, N));
        float relative_plane_dist = dist_to_plane / Z;
        float w_ = clamp(1.0 - abs(dist_to_plane) * plane_dist_norm, 0.0, 1.0);

        float w_hit_dist = exp(-3.0 * abs(s.a - hit_t0) * global_constants.data.hit_distance_scale);

        if (global_constants.data.use_geometry_weight == 1)
            w *= w_;

        if (global_constants.data.use_normal_weight == 1)
            w *= w_n;

        if (global_constants.data.use_hit_distance_weight == 1)
            w *= w_hit_dist;

        w = is_in_screen ? w : 0.0;
        s = is_in_screen ? s : vec4(0.0);
        
        sum += w;
        diff += s * w;
    }

    diff /= sum;

    imageStore(blurred_output, p.xy, diff);
}